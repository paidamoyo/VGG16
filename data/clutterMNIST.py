# -*- coding: utf-8 -*-
"""
Created on Thu Oct 13 10:54:22 2016

@author: Kevin Liang

Creates much larger MNIST images

Embeds MNIST handwritten in a much larger image. Option to add clutter, to an
adjustable degree. Clutter generated from random pieces of MNIST digits
"""

import gzip
import numpy as np
import os
import pickle
import urllib.request


class ClutteredMnist():
    def __init__(self, flags):
        self.data_directory = flags['data_directory'] + '/MNIST/'
        self.data_file = 'mnist.pkl.gz'
        self.train_set, self.valid_set, self.test_set = self.load_data()

    def load_data(self):
        """
        Loads the dataset
        """

        # Check if MNIST is in the data directory.
        new_path = os.path.join(os.path.split(__file__)[0], self.data_directory)
        if os.path.isfile(new_path):
            self.data_directory = new_path
        else:
            origin = 'http://www.iro.umontreal.ca/~lisa/deep/data/mnist/mnist.pkl.gz'
            print('Downloading data from %s' % origin)
            urllib.request.urlopen(origin, self.data_directory)
        print('... loading data')

        # Load the dataset
        with gzip.open(self.data_directory, 'rb') as f:
            try:
                train_set, valid_set, test_set = pickle.load(f, encoding='latin1')
            except:
                train_set, valid_set, test_set = pickle.load(f)

        print('Successfully loaded MNIST data')
        return [train_set, valid_set, test_set]

    def generate_training_batch(self, dims, num_images, numbers, prob, clutter):
        """
        :param dims: dimensions of output cluttered MNIST images
        :param num_images: number of images to output
        :param numbers: array of MNIST digits (28x28) to insert into each image
        :param prob: probability of generating a number from numbers
        :param clutter: degree of clutter in image. Clutter generated by inserting 8x8
                        patches of other digits into image. Clutter ratio determined
                        by proportion of 8x8 patches to have MNIST piece
        :return: images: 3D stack of cluttered MNIST images (dim[0],dim[1],nImages)
        """
        images = np.zeros((num_images, dims[0], dims[1]))
        labels = np.ones(num_images)

        # Calculate number of patches of clutter to add in
        clutter_patches = int(clutter * dims[0] * dims[1] / (8 * 8))

        for k in range(num_images):
            # Add in MNIST digits
            for i in numbers:
                if prob < np.random.uniform(low=0, high=1):
                    continue
                else:
                    # Randomly select MNIST data of the correct digit
                    index = np.where(self.train_set[1] == i)[0]
                    digit = self.train_set[0][np.random.choice(index), :]
                    digit = np.reshape(digit, (28, 28))

                    if dims[0] != 28 or dims[1] != 28:
                        # Randomly choose location
                        x = np.random.randint(low=0, high=dims[0] - 28)
                        y = np.random.randint(low=0, high=dims[1] - 28)

                        # Insert digit
                        images[k, x:x + 28, y:y + 28] += digit
                    else:
                        images[k, :, :] = digit
                    labels[k] = -1

            # Add in clutter
            if clutter_patches != 0:
                for j in range(clutter_patches):
                    # Randomly select MNIST digit
                    index = np.random.choice(len(self.train_set[1]))
                    digit = np.reshape(self.train_set[0][index, :], (28, 28))

                    # Randomly select patch of selected digit
                    px = np.random.randint(low=0, high=28 - 8)
                    py = np.random.randint(low=0, high=28 - 8)

                    # Randomly choose location to insert clutter
                    x = np.random.randint(low=0, high=dims[0] - 8)
                    y = np.random.randint(low=0, high=dims[1] - 8)

                    # Insert digit fragment and return to 8 bit
                    images[k, x:x + 8, y:y + 8] += digit[px:px + 8, py:py + 8]
                    for x1 in range(x, x + 8):
                        for y1 in range(y, y+8):
                            if images[k, x1, y1] > 255:
                                images[k, x1, y1] = 255

            # Renormalize image
            images[k, :, :] = images[k, :, :] - images[k, :, :].mean()
        return labels, np.expand_dims(images, 3)


if __name__ == '__main__':
    flags = {'data_directory': '../../Data'}
    data = ClutteredMnist(flags)
    image_stack = data.generate_training_batch(dims=[200, 200], num_images=10, numbers=[5, 8, 2], prob=0.1, clutter=0.2)
